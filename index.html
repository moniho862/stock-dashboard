/***********************
 * 存股儀表板 v7.5（繁中 / API + Sheet）
 * 你目前需求重點：
 * 1) 美股/ibrAin 市值(台幣) = 股數 * 最新USD股價 * 最新USDTWD（小數點2位）
 * 2) 價格快取：寫入匯率欄位（USDTWD）
 * 3) GitHub 前端可用：GET API（getDashboard / refreshPrices / addTransaction）
 * 4) 分頁籤資料可分 market=ALL|TW|US|IB
 * 5) 匯率抓取：GoogleFinance 失敗時改用 UrlFetchApp 公開匯率來源
 ***********************/

const TZ = "Asia/Taipei";

const SHEET_TX = "交易紀錄";
const SHEET_DCA = "定期定額設定";
const SHEET_SYMBOLS = "股票清單";
const SHEET_PRICE = "價格快取";

const BASE_CCY = "台幣";

// =============== Web App Router（給 Apps Script / GitHub 用） ===============
function doGet(e) {
  ensureSheets_();

  const p = (e && e.parameter) ? e.parameter : {};
  const action = String(p.action || "").trim();

  try {
    if (!action) {
      // 你若仍要用 Apps Script 內建 Index.html，可在此回 HtmlOutput
      // 但你現在要 GitHub，通常不需要 Apps Script 出 UI
      return jsonOut_({ ok: true, message: "API Ready", actions: ["getDashboard", "refreshPrices", "addTransaction"] }, p);
    }

    if (action === "getDashboard") {
      const market = String(p.market || "ALL").toUpperCase(); // ALL | TW | US | IB
      const payload = getDashboard_(market);
      return jsonOut_(payload, p);
    }

    if (action === "refreshPrices") {
      const r = refreshPrices_();
      return jsonOut_(r, p);
    }

    if (action === "addTransaction") {
      // GitHub 用 GET 寫入
      const r = addTransaction_(p);
      return jsonOut_(r, p);
    }

    if (action === "init") {
      return jsonOut_({ ok: true, message: "初始化完成" }, p);
    }

    return jsonOut_({ ok: false, message: "未知 action: " + action }, p);

  } catch (err) {
    return jsonOut_({ ok: false, message: String(err && err.message ? err.message : err), stack: String(err && err.stack ? err.stack : "") }, p);
  }
}

/**
 * 若 GitHub 用 fetch + CORS 你可能會遇到限制。
 * 最穩做法：用 JSONP（加上 &callback=xxx）
 */
function jsonOut_(obj, params) {
  const callback = String((params && params.callback) || "").trim();
  const text = callback ? `${callback}(${JSON.stringify(obj)});` : JSON.stringify(obj);
  return ContentService
    .createTextOutput(text)
    .setMimeType(ContentService.MimeType.JAVASCRIPT);
}

// ========================= 交易：新增 / 更新 =========================
function addTransaction_(data) {
  ensureSheets_();
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_TX);

  const now = new Date();
  const id = "TX-" + Utilities.formatDate(now, TZ, "yyyyMMddHHmmss") + "-" + Math.floor(Math.random() * 100000);

  const date = parseDate_(data.date);
  const symbol = normalizeSymbol_(data.symbol);

  const type = String(data.type || "").trim();        // 買入/賣出/股利
  const source = String(data.source || "").trim();    // 手動買入/定期定額
  const broker = String(data.broker || "").trim();
  const currency = String(data.currency || "台幣").trim(); // 台幣/美金

  const amount = num_(data.amount);                  // 交易金額（幣別=台幣 代表投入台幣；幣別=美金 代表美元金額）
  const qty = blankOrNum_(data.qty);
  const price = blankOrNum_(data.price);             // 台股=台幣價；美股=美元價
  const fx = blankOrNum_(data.fx);                   // 台幣/美金 匯率
  const fee = blankOrNum_(data.fee);
  const tax = blankOrNum_(data.tax);
  const note = String(data.note || "");

  if (!date) throw new Error("交易日期格式錯誤（建議 YYYY-MM-DD）");
  if (!symbol) throw new Error("股票代號不可空白");
  if (!["買入", "賣出", "股利"].includes(type)) throw new Error("交易類型需為：買入 / 賣出 / 股利");
  if (!["手動買入", "定期定額"].includes(source)) throw new Error("來源類型需為：手動買入 / 定期定額");
  if (!(amount > 0)) throw new Error("交易金額需大於 0");

  ensureSymbolExists_(symbol);

  const cls = classifySymbol_(symbol);

  let finalQty = qty;
  let finalPrice = price;

  if (type === "股利") {
    finalQty = "";
    finalPrice = "";
  } else {
    if (cls === "US" || cls === "IB") {
      // 美股/IB：若未填股數但有填股價，嘗試推算
      // 幣別=台幣：qty = (amountTWD / fx) / priceUSD
      // 幣別=美金：qty = amountUSD / priceUSD
      if (finalQty === "" && finalPrice !== "") {
        if (currency === "台幣") {
          if (fx !== "" && fx > 0) finalQty = (amount / fx) / finalPrice;
        } else if (currency === "美金") {
          finalQty = (amount / finalPrice);
        }
      }
    } else {
      // 台股： qty/price 互推
      if (finalQty !== "" && finalPrice === "") finalPrice = safeDiv_(amount, finalQty);
      if (finalQty === "" && finalPrice !== "") finalQty = safeDiv_(amount, finalPrice);
    }
  }

  let status = "草稿";
  if (type === "股利") status = "已確認";
  else if (finalQty !== "" && finalPrice !== "" && isFinite(finalQty) && isFinite(finalPrice)) status = "已確認";

  const row = sh.getLastRow() + 1;
  const values = [
    id,
    formatDate_(date),
    symbol,
    type,
    source,
    broker,
    amount,
    finalQty === "" ? "" : round_(finalQty, 6),
    finalPrice === "" ? "" : round_(finalPrice, 6),
    fx === "" ? "" : fx,
    fee === "" ? "" : fee,
    tax === "" ? "" : tax,
    currency,
    status,
    note,
    now,
    now
  ];

  sh.getRange(row, 1, 1, values.length).setValues([values]);

  // 股票代號強制文字（避免前導0消失）
  const symbolCell = sh.getRange(row, 3);
  symbolCell.setNumberFormat("@");
  symbolCell.setValue(symbol);

  return { ok: true, id };
}

// ========================= 定期定額：只補到今天（含） =========================
function generateDcaDrafts() {
  ensureSheets_();
  const ss = SpreadsheetApp.getActive();
  const shPlan = ss.getSheetByName(SHEET_DCA);
  const shTx = ss.getSheetByName(SHEET_TX);

  const plans = shPlan.getDataRange().getValues();
  if (plans.length <= 1) return { ok: true, created: 0, message: "沒有定期定額設定" };

  const tx = shTx.getDataRange().getValues();
  const txHeader = tx[0];

  const idxTx = {
    symbol: txHeader.indexOf("股票代號"),
    source: txHeader.indexOf("來源類型"),
    date: txHeader.indexOf("交易日期"),
  };

  const existing = new Set();
  for (let i = 1; i < tx.length; i++) {
    const row = tx[i];
    if (String(row[idxTx.source]) !== "定期定額") continue;
    const symbol = normalizeSymbol_(row[idxTx.symbol]);
    const ym = toYearMonth_(row[idxTx.date]);
    if (symbol && ym) existing.add(symbol + "|" + ym);
  }

  const planHeader = plans[0];
  const col = (name) => planHeader.indexOf(name);

  const today = new Date();
  const todayYM = Utilities.formatDate(today, TZ, "yyyy-MM");
  const todayYMD = Utilities.formatDate(today, TZ, "yyyy-MM-dd");

  let created = 0;

  for (let i = 1; i < plans.length; i++) {
    const p = plans[i];
    const enabled = String(p[col("是否啟用")] || "").trim() === "是";
    if (!enabled) continue;

    const symbol = normalizeSymbol_(p[col("股票代號")]);
    const day = parseInt(p[col("每月扣款日")], 10);
    const amount = num_(p[col("每月扣款金額")]);
    const currency = String(p[col("幣別")] || "台幣").trim();

    let startYM = toYearMonth_(p[col("開始月份(YYYY-MM)")]);
    if (!startYM) startYM = todayYM;

    if (!symbol || !(day >= 1 && day <= 28) || !(amount > 0)) continue;

    ensureSymbolExists_(symbol);

    const months = enumerateMonths_(startYM, todayYM);

    months.forEach(ym => {
      const due = Utilities.formatDate(makeDateFromYMDay_(ym, day), TZ, "yyyy-MM-dd");
      if (todayYMD < due) return; // 本月尚未到扣款日，不產生

      const key = symbol + "|" + ym;
      if (existing.has(key)) return;

      const targetDate = adjustWeekend_(makeDateFromYMDay_(ym, day));
      const note = `定期定額 ${ym}`;

      addTransaction_({
        date: Utilities.formatDate(targetDate, TZ, "yyyy-MM-dd"),
        symbol,
        type: "買入",
        source: "定期定額",
        broker: "",
        amount,
        qty: "",
        price: "",
        fx: "",
        fee: "",
        tax: "",
        currency,
        note
      });

      existing.add(key);
      created++;
    });
  }

  return { ok: true, created };
}

// 清除未到期定期定額草稿
function purgeFutureDcaDrafts() {
  ensureSheets_();
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_TX);

  const v = sh.getDataRange().getValues();
  if (v.length <= 1) return { ok: true, deleted: 0 };

  const header = v[0];
  const col = (name) => header.indexOf(name);

  const idx = {
    date: col("交易日期"),
    source: col("來源類型"),
    status: col("狀態"),
  };

  const today = new Date();
  const todayYMD = Utilities.formatDate(today, TZ, "yyyy-MM-dd");

  let deleted = 0;
  for (let i = v.length - 1; i >= 1; i--) {
    const r = v[i];
    const source = String(r[idx.source] || "");
    const status = String(r[idx.status] || "");
    const d = parseDate_(String(r[idx.date] || ""));
    if (!d) continue;

    const ymd = Utilities.formatDate(d, TZ, "yyyy-MM-dd");
    if (source === "定期定額" && status === "草稿" && ymd > todayYMD) {
      sh.deleteRow(i + 1);
      deleted++;
    }
  }

  return { ok: true, deleted };
}

// ========================= 價格更新 / 匯率更新 =========================
function refreshPrices_() {
  ensureSheets_();
  const ss = SpreadsheetApp.getActive();
  const list = readSymbolList_();
  const sh = ss.getSheetByName(SHEET_PRICE);

  sh.clearContents();
  sh.getRange(1, 1, 1, 8).setValues([[
    "股票代號", "GoogleFinance代號", "報價幣別", "收盤價(原幣)", "匯率(若需)", "收盤價(台幣)", "更新時間", "狀態"
  ]]);
  sh.getRange("A:A").setNumberFormat("@");

  // 取得 USDTWD（若需要）
  const needUsd = list.some(x => x.quoteCcy === "美金");
  const usdTwd = needUsd ? getUsdTwdRate_() : "";

  const now = new Date();
  let row = 2;

  list.forEach(s => {
    const gf = String(s.gf || "").trim();
    if (!gf) {
      sh.getRange(row, 1, 1, 8).setValues([[
        s.symbol, "", s.quoteCcy, "", "", "", now, "缺少GoogleFinance代號（請到股票清單補）"
      ]]);
      row++;
      return;
    }

    const closeOrig = getGoogleFinanceLastPrice_(gf); // 台股=台幣，美股=美元
    if (closeOrig === "") {
      sh.getRange(row, 1, 1, 8).setValues([[
        s.symbol, gf, s.quoteCcy, "", usdTwd || "", "", now, "抓價失敗"
      ]]);
      row++;
      return;
    }

    let fx = "";
    let closeTwd = closeOrig;

    if (s.quoteCcy === "美金") {
      fx = usdTwd;
      if (fx !== "" && isFinite(Number(fx))) {
        closeTwd = Number(closeOrig) * Number(fx);
      } else {
        closeTwd = "";
      }
    }

    sh.getRange(row, 1, 1, 8).setValues([[
      s.symbol,
      gf,
      s.quoteCcy,
      round_(Number(closeOrig), 6),
      fx === "" ? "" : round_(Number(fx), 6),
      closeTwd === "" ? "" : round_(Number(closeTwd), 4),
      now,
      (s.quoteCcy === "美金" && (fx === "" || !isFinite(Number(fx)))) ? "匯率抓取失敗" : "OK"
    ]]);
    row++;
  });

  sh.setFrozenRows(1);
  sh.autoResizeColumns(1, 8);

  return { ok: true, updated: list.length, usdTwd: usdTwd || "" };
}

// 每日觸發器（如果你要）
function dailyPriceJob() { refreshPrices_(); }

function createDailyTrigger() {
  ScriptApp.getProjectTriggers().forEach(t => {
    if (t.getHandlerFunction() === "dailyPriceJob") ScriptApp.deleteTrigger(t);
  });

  ScriptApp.newTrigger("dailyPriceJob")
    .timeBased()
    .everyDays(1)
    .atHour(18)
    .create();

  return { ok: true, message: "已建立每日觸發器（18:00 執行）" };
}

/**
 * 匯率抓取：優先 GoogleFinance，失敗改用 UrlFetchApp 公開來源
 * 回傳：USDTWD（number or ""）
 */
function getUsdTwdRate_() {
  // 1) 優先：GoogleFinance
  const gf = getGoogleFinanceSingle_("CURRENCY:USDTWD");
  if (gf !== "" && isFinite(Number(gf)) && Number(gf) > 0) return Number(gf);

  // 2) fallback：exchangerate.host（免 key）
  try {
    const url = "https://api.exchangerate.host/latest?base=USD&symbols=TWD";
    const res = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
    const code = res.getResponseCode();
    if (code >= 200 && code < 300) {
      const json = JSON.parse(res.getContentText());
      const rate = json && json.rates && json.rates.TWD;
      if (rate && isFinite(Number(rate)) && Number(rate) > 0) return Number(rate);
    }
  } catch (e) {}

  // 3) fallback：floatrates（備援）
  try {
    const url2 = "https://www.floatrates.com/daily/usd.json";
    const res2 = UrlFetchApp.fetch(url2, { muteHttpExceptions: true });
    const code2 = res2.getResponseCode();
    if (code2 >= 200 && code2 < 300) {
      const json2 = JSON.parse(res2.getContentText());
      const rate2 = json2 && json2.twd && json2.twd.rate;
      if (rate2 && isFinite(Number(rate2)) && Number(rate2) > 0) return Number(rate2);
    }
  } catch (e) {}

  return "";
}

/**
 * 取單一 price：=GOOGLEFINANCE("ticker","price")
 */
function getGoogleFinanceSingle_(ticker) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_PRICE);

  // 用不會干擾表格的隱藏欄位
  const cell = sh.getRange("J1");
  cell.setFormula(`=IFERROR(GOOGLEFINANCE("${ticker}","price"),"")`);
  SpreadsheetApp.flush();
  Utilities.sleep(900);

  const val = cell.getValue();
  cell.clearContent();

  if (val === "" || val === 0) return "";
  return val;
}

/**
 * 取最近可用價格：用 GOOGLEFINANCE 的 price（過去 10 天）抓最後一筆數字
 */
function getGoogleFinanceLastPrice_(ticker) {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_PRICE);

  const startCell = sh.getRange("J2");
  startCell.setFormula(`=IFERROR(GOOGLEFINANCE("${ticker}","price",TODAY()-10,TODAY()),"")`);
  SpreadsheetApp.flush();
  Utilities.sleep(1400);

  const range = sh.getRange("J2:K60").getValues();
  startCell.clearContent();

  let last = "";
  for (let i = 0; i < range.length; i++) {
    const price = range[i][1];
    if (typeof price === "number" && isFinite(price) && price > 0) last = price;
  }
  return last === "" ? "" : last;
}

// ========================= Dashboard（依 market 篩選） =========================
function getDashboard_(market) {
  ensureSheets_();

  const ss = SpreadsheetApp.getActive();
  const priceSh = ss.getSheetByName(SHEET_PRICE);
  if (priceSh.getLastRow() <= 1) {
    try { refreshPrices_(); } catch (e) {}
  }

  const shTx = ss.getSheetByName(SHEET_TX);
  const values = shTx.getDataRange().getValues();
  if (values.length <= 1) {
    return { ok: true, market, summary: baseSummary_(), holdings: [], allocation: [], drafts: [], priceUpdatedAt: "" };
  }

  const header = values[0];
  const col = (name) => header.indexOf(name);

  const rows = values.slice(1).map(r => ({
    id: String(r[col("交易編號")]),
    date: String(r[col("交易日期")]),
    symbol: normalizeSymbol_(r[col("股票代號")]),
    type: String(r[col("交易類型")]),
    source: String(r[col("來源類型")]),
    broker: String(r[col("證券商")] || ""),
    amount: num0_(r[col("交易金額")]),
    qty: r[col("股數")] === "" ? "" : num0_(r[col("股數")]),
    price: r[col("成交單價")] === "" ? "" : num0_(r[col("成交單價")]),
    fx: r[col("匯率(台幣/美金)")] === "" ? "" : num0_(r[col("匯率(台幣/美金)")]),
    fee: r[col("手續費")] === "" ? "" : num0_(r[col("手續費")]),
    tax: r[col("交易稅")] === "" ? "" : num0_(r[col("交易稅")]),
    currency: String(r[col("幣別")] || "台幣"),
    status: String(r[col("狀態")]),
    note: String(r[col("備註")])
  }));

  const drafts = rows
    .filter(x => x.status === "草稿" && x.type !== "股利")
    .sort((a, b) => a.date.localeCompare(b.date));

  const symbolMap = getSymbolMap_();
  const priceMap = readPriceCache_();

  // 全部持股（先算出來，再依 market 篩）
  const allHoldings = calcHoldingsWithPnl_(rows, symbolMap, priceMap);

  const holdings = filterHoldingsByMarket_(allHoldings, market);

  const totalMV = holdings.reduce((s, h) => s + (h.marketValue || 0), 0);
  const totalCost = holdings.reduce((s, h) => s + (Number(h.cost) || 0), 0);
  const totalPnl = (totalMV > 0) ? (totalMV - totalCost) : 0;
  const totalRr = (totalCost > 0 && totalMV > 0) ? (totalPnl / totalCost) : 0;

  const allocation = holdings
    .map(h => ({
      symbol: h.symbol,
      name: h.name,
      value: h.marketValue || 0,
      pct: totalMV > 0 ? (h.marketValue || 0) / totalMV : 0
    }))
    .filter(x => x.value > 0)
    .sort((a, b) => b.value - a.value);

  return {
    ok: true,
    market,
    summary: {
      totalMarketValue: round_(totalMV, 2), // 允許到小數點2位
      totalCost: round_(totalCost, 0),
      totalPnl: round_(totalPnl, 2),
      totalRr: totalRr
    },
    holdings,
    allocation,
    drafts,
    priceUpdatedAt: getPriceUpdatedAt_()
  };
}

function filterHoldingsByMarket_(holdings, market) {
  const m = String(market || "ALL").toUpperCase();
  if (m === "ALL") return holdings;

  return holdings.filter(h => {
    const cls = classifySymbol_(h.symbol);
    if (m === "TW") return cls === "TW";
    if (m === "US") return cls === "US";
    if (m === "IB") return cls === "IB";
    return true;
  });
}

/**
 * 持股 + 損益
 * ✅ 美股/IB 市值(台幣) = 股數 * 最新USD股價 * 最新USDTWD
 */
function calcHoldingsWithPnl_(rows, symbolMap, priceMap) {
  const map = new Map();
  const confirmed = rows.filter(x => x.status === "已確認" && (x.type === "買入" || x.type === "賣出"));

  confirmed.forEach(tx => {
    const key = normalizeSymbol_(tx.symbol);
    if (!key) return;

    if (!map.has(key)) map.set(key, { symbol: key, qty: 0, cost: 0, avgCost: 0 });

    const h = map.get(key);
    const qty = Number(tx.qty);
    if (!(qty > 0)) return;

    // 成本一律換算成台幣
    const amountTwd = toTwd_(Number(tx.amount || 0), tx.currency, Number(tx.fx || 0));
    const feeTwd = toTwd_(Number(tx.fee || 0), tx.currency, Number(tx.fx || 0));
    const taxTwd = toTwd_(Number(tx.tax || 0), tx.currency, Number(tx.fx || 0));
    const buyCostTwd = amountTwd + feeTwd + taxTwd;

    if (tx.type === "買入") {
      h.qty += qty;
      h.cost += buyCostTwd;
    } else {
      const avg = h.qty > 0 ? (h.cost / h.qty) : 0;
      h.qty -= qty;
      h.cost -= avg * qty;
      if (h.qty < 0) h.qty = 0;
      if (h.cost < 0) h.cost = 0;
    }

    h.avgCost = h.qty > 0 ? (h.cost / h.qty) : 0;
  });

  return Array.from(map.values())
    .filter(x => x.qty > 0)
    .map(h => {
      const name = symbolMap[h.symbol] || "";
      const p = priceMap[h.symbol] || {};

      const cls = classifySymbol_(h.symbol);

      const closeOrig = Number(p.closeOrig) || 0; // 台股=台幣，美股=USD
      const fx = Number(p.fx) || 0;               // USDTWD

      let closeTwd = 0;

      if (cls === "TW") {
        closeTwd = closeOrig; // 台股原幣就是台幣
      } else {
        // ✅ 美股/IB：USD * 匯率
        if (closeOrig > 0 && fx > 0) closeTwd = closeOrig * fx;
      }

      const marketValue = closeTwd > 0 ? h.qty * closeTwd : 0;
      const pnl = marketValue - h.cost;
      const rr = (h.cost > 0) ? pnl / h.cost : 0;

      return {
        symbol: h.symbol,
        name,
        cls,
        qty: round_(h.qty, 6),
        cost: round_(h.cost, 0),
        avgCost: round_(h.avgCost, 6),
        closeOrig: closeOrig > 0 ? round_(closeOrig, 4) : "",
        fx: fx > 0 ? round_(fx, 4) : "",
        closeTwd: closeTwd > 0 ? round_(closeTwd, 2) : "",
        marketValue: marketValue > 0 ? round_(marketValue, 2) : 0,
        pnl: round_(pnl, 2),
        rr
      };
    })
    .sort((a, b) => b.marketValue - a.marketValue);
}

function toTwd_(value, currency, fx) {
  if (!value) return 0;
  const c = String(currency || "台幣").trim();
  if (c === "台幣") return value;
  if (c === "美金") {
    if (!(fx > 0)) return value; // 沒匯率就先不換（避免 NaN）
    return value * fx;
  }
  return value;
}

// ========================= 股票清單 / 價格快取讀寫 =========================
function ensureSymbolExists_(symbol) {
  const s = normalizeSymbol_(symbol);
  if (!s) return;

  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_SYMBOLS);
  const v = sh.getDataRange().getValues();
  if (v.length <= 1) return;

  const header = v[0];
  const col = (name) => header.indexOf(name);
  const idxSymbol = col("股票代號");

  for (let i = 1; i < v.length; i++) {
    if (normalizeSymbol_(v[i][idxSymbol]) === s) return;
  }

  let gf = "";
  if (/^\d{4,5}$/.test(s)) gf = `TPE:${s}`;

  const cls = classifySymbol_(s);
  const quoteCcy = (cls === "US" || cls === "IB") ? "美金" : "台幣";

  const row = sh.getLastRow() + 1;
  sh.getRange(row, 1, 1, 7).setValues([[
    s, "", gf, quoteCcy, "", "", "自動新增：請確認 GoogleFinance代號 是否正確"
  ]]);

  const symbolCell = sh.getRange(row, 1);
  symbolCell.setNumberFormat("@");
  symbolCell.setValue(s);
}

function readSymbolList_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_SYMBOLS);
  const v = sh.getDataRange().getValues();
  if (v.length <= 1) return [];

  const header = v[0];
  const col = (name) => header.indexOf(name);

  const out = [];
  for (let i = 1; i < v.length; i++) {
    const r = v[i];
    const symbol = normalizeSymbol_(r[col("股票代號")]);
    if (!symbol) continue;
    out.push({
      symbol,
      gf: String(r[col("GoogleFinance代號")] || "").trim(),
      quoteCcy: String(r[col("報價幣別")] || BASE_CCY).trim() || BASE_CCY
    });
  }
  return out;
}

function getSymbolMap_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_SYMBOLS);
  const v = sh.getDataRange().getValues();
  if (v.length <= 1) return {};

  const header = v[0];
  const col = (name) => header.indexOf(name);

  const m = {};
  for (let i = 1; i < v.length; i++) {
    const r = v[i];
    const symbol = normalizeSymbol_(r[col("股票代號")]);
    const name = String(r[col("股票名稱")] || "").trim();
    if (symbol) m[symbol] = name;
  }
  return m;
}

function readPriceCache_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_PRICE);
  const v = sh.getDataRange().getValues();
  if (v.length <= 1) return {};

  const header = v[0];
  const col = (name) => header.indexOf(name);

  const m = {};
  for (let i = 1; i < v.length; i++) {
    const r = v[i];
    const symbol = normalizeSymbol_(r[col("股票代號")]);
    if (!symbol) continue;
    m[symbol] = {
      closeOrig: r[col("收盤價(原幣)")],
      fx: r[col("匯率(若需)")],
      closeTwd: r[col("收盤價(台幣)")],
      quoteCcy: String(r[col("報價幣別")] || BASE_CCY)
    };
  }
  return m;
}

function getPriceUpdatedAt_() {
  const ss = SpreadsheetApp.getActive();
  const sh = ss.getSheetByName(SHEET_PRICE);
  const last = sh.getLastRow();
  if (last <= 1) return "";
  const t = sh.getRange(2, 7, 1, 1).getValue();
  return t ? Utilities.formatDate(new Date(t), TZ, "yyyy-MM-dd HH:mm") : "";
}

// ========================= Sheet 初始化 / 格式 =========================
function ensureSheets_() {
  const ss = SpreadsheetApp.getActive();

  ensureSheet_(ss, SHEET_TX, [
    "交易編號", "交易日期", "股票代號", "交易類型", "來源類型", "證券商",
    "交易金額", "股數", "成交單價", "匯率(台幣/美金)", "手續費", "交易稅",
    "幣別", "狀態", "備註", "建立時間", "更新時間"
  ]);

  ensureSheet_(ss, SHEET_DCA, [
    "定期定額編號", "股票代號", "每月扣款日", "每月扣款金額", "幣別",
    "開始月份(YYYY-MM)", "假日處理方式", "是否啟用", "備註", "建立時間", "更新時間"
  ]);

  ensureSheet_(ss, SHEET_SYMBOLS, [
    "股票代號", "股票名稱", "GoogleFinance代號", "報價幣別", "市場別", "類型", "備註"
  ]);

  ensureSheet_(ss, SHEET_PRICE, [
    "股票代號", "GoogleFinance代號", "報價幣別", "收盤價(原幣)", "匯率(若需)", "收盤價(台幣)", "更新時間", "狀態"
  ]);

  forceTextFormatForSymbolColumns_();
}

function ensureSheet_(ss, name, headers) {
  let sh = ss.getSheetByName(name);
  if (!sh) sh = ss.insertSheet(name);

  const range = sh.getRange(1, 1, 1, headers.length);
  const current = range.getValues()[0];

  const needInit = current.every(x => x === "");
  if (needInit) {
    range.setValues([headers]);
    sh.setFrozenRows(1);
    sh.autoResizeColumns(1, headers.length);
  }
}

function forceTextFormatForSymbolColumns_() {
  const ss = SpreadsheetApp.getActive();
  const tx = ss.getSheetByName(SHEET_TX);
  if (tx) tx.getRange("C:C").setNumberFormat("@");
  const sym = ss.getSheetByName(SHEET_SYMBOLS);
  if (sym) sym.getRange("A:A").setNumberFormat("@");
  const dca = ss.getSheetByName(SHEET_DCA);
  if (dca) dca.getRange("B:B").setNumberFormat("@");
  const price = ss.getSheetByName(SHEET_PRICE);
  if (price) price.getRange("A:A").setNumberFormat("@");
}

// ========================= 分類：台股/美股/IB =========================
function classifySymbol_(sym) {
  const s = String(sym || "").trim();
  const up = s.toUpperCase();
  if (up === "IBRAIN") return "IB";
  if (/^\d+$/.test(s)) return "TW";
  if (/^[A-Za-z]/.test(s)) return "US";
  return "TW";
}

// ========================= 小工具 =========================
function baseSummary_() {
  return { totalMarketValue: 0, totalCost: 0, totalPnl: 0, totalRr: 0 };
}

function parseDate_(s) {
  if (!s) return null;
  if (Object.prototype.toString.call(s) === "[object Date]" && !isNaN(s)) return s;
  const str = String(s).trim().replaceAll("/", "-");
  const m = str.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (!m) return null;
  const d = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
  return isNaN(d) ? null : d;
}

function formatDate_(d) {
  return Utilities.formatDate(d, TZ, "yyyy-MM-dd");
}

function normalizeSymbol_(s) {
  if (s === null || s === undefined) return "";
  return String(s).trim().toUpperCase();
}

function num_(x) {
  const n = Number(x);
  if (!isFinite(n)) throw new Error("數字欄位格式錯誤：" + x);
  return n;
}

function num0_(x) {
  const n = Number(x);
  return isFinite(n) ? n : 0;
}

function blankOrNum_(x) {
  if (x === "" || x === null || x === undefined) return "";
  const n = Number(x);
  if (!isFinite(n)) throw new Error("數字欄位格式錯誤：" + x);
  return n;
}

function round_(n, digits) {
  const p = Math.pow(10, digits);
  return Math.round(n * p) / p;
}

function safeDiv_(a, b) {
  const bn = Number(b);
  if (!(bn > 0)) throw new Error("除數不可為 0 或空值");
  return Number(a) / bn;
}

function toYearMonth_(value) {
  if (!value) return "";
  if (Object.prototype.toString.call(value) === "[object Date]" && !isNaN(value)) {
    return Utilities.formatDate(value, TZ, "yyyy-MM");
  }
  const s = String(value).trim().replaceAll("/", "-");
  let m = s.match(/^(\d{4})-(\d{2})$/);
  if (m) return `${m[1]}-${m[2]}`;
  m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (m) return `${m[1]}-${m[2]}`;
  return "";
}

function enumerateMonths_(startYM, endYM) {
  const [sy, sm] = startYM.split("-").map(x => parseInt(x, 10));
  const [ey, em] = endYM.split("-").map(x => parseInt(x, 10));
  if (!(sy && sm && ey && em)) return [];
  const out = [];
  let y = sy, m = sm;
  while (y < ey || (y === ey && m <= em)) {
    out.push(`${y}-${String(m).padStart(2, "0")}`);
    m++;
    if (m === 13) { m = 1; y++; }
  }
  return out;
}

function makeDateFromYMDay_(ym, day) {
  const [y, m] = ym.split("-").map(x => parseInt(x, 10));
  return new Date(y, m - 1, day);
}

function adjustWeekend_(d) {
  const day = d.getDay();
  if (day === 6) d.setDate(d.getDate() + 2);
  if (day === 0) d.setDate(d.getDate() + 1);
  return d;
}
